Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

 

Example 1:
test case=> [3,3]   o/p=>[0,1]
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]
 
Constraints: O(n)
 Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?


1st approach => 

vector<int>v;
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(a[i]+a[j]==target){
                    v.push_back(i);
                    v.push_back(j);
                  
                }
            }
        }
        return v;;
// here time complexity=> O(n^2)

2nd approach=> optimized => use of hash map table
1. maintain array element with its indices in hash map table
2.in 2d loop substract current array element and check wheather remainder is presen in hash map or nor if remaider is present then simply return its index

unordered_map<int,int>m;
        vector<int>v;
//maintiang every array element with its indices in hash map table
        for(int i=0;i<n;i++){
            m[a[i]]=i;
        }
       
        for(int i=0;i<n;i++){
//substract target with current array element and chack wheather remaider is present in hash map or not if present then simply return tis index 
            int k=target-a[i];
            if((m[k]!=0) && m[k]!=i){
                v.push_back(i);
                v.push_back(m[k]);
                return v;
            }
